/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package rresult

class RResult <out T, out E> @PublishedApi internal constructor(
    @PublishedApi internal val value: Any?)
{
    private val isSuccess: Boolean get() = value !is Failure<*>

    public val isFailure: Boolean get() = value is Failure<*>

    public inline fun getOrNull(): T? =
        when {
            isFailure -> null
            else -> value as T
        }

    public fun <E> errorOrNull(): E? =
        when (value) {
            is Failure<*> -> value.error as E
            else -> null
        }

    public override fun toString(): String =
        when (value) {
            is Failure<*> -> value.error.toString() // "Failure($exception)"
            else -> "Success($value)"
        }

    public companion object {
        /**
         * Returns an instance that encapsulates the given [value] as successful value.
         */
        public inline fun <T, E> success(value: T): RResult<T, E> =
            RResult(value)

        /**
         * Returns an instance that encapsulates the given [Throwable] [exception] as failure.
         */
        public inline fun <T, E> failure(exception: Throwable): RResult<T, E> =
            RResult(createFailure(exception))
    }




    internal class Failure<E>(
        val error: E
    )  {
        override fun equals(other: Any?): Boolean = other is Failure<*>
        override fun toString(): String = "Failure($error)"
        override fun hashCode(): Int {
            return error?.hashCode() ?: 0
        }
    }
}

@PublishedApi
internal fun <E> createFailure(error: E): Any =
    RResult.Failure(error)

public inline fun <R, E, T : R> RResult<T, E>.getOrElse(onFailure: (error: E) -> R): R {
    return when (val error = errorOrNull<E>()) {
        null -> value as T
        else -> onFailure(error)
    }
}
